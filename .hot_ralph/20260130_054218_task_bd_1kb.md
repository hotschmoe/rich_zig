I'll implement row/column spanning (merged cells) for the Table component. Let me start by exploring the current table implementation.Now let me read the actual table.zig file to see the current implementation in detail.Now I have a complete understanding of the current implementation. Let me also look at how rich_rust or Python's Rich handles cell spanning for reference.Now let me design and implement cell spanning. The key design decisions:

1. **Cell type**: A `Cell` struct that holds content plus optional `colspan` and `rowspan`
2. **SpannedRow type**: A row that can contain spanning cells
3. **Grid-based rendering**: Track which grid positions are "occupied" by spans from prior rows
4. **Border handling**: Omit vertical separators within column spans, handle horizontal borders properly

Let me implement this:Now I need to add the spanned_rows storage to the Table struct and add methods for adding spanned rows:Now I need to add the method for adding spanned rows. Let me find the right location (after addRowRichStyled):Now I need to update the width calculation to handle spanned cells. The key insight is that a spanning cell's width contributes to the measurement, but it spans multiple columns - so we need to consider how content fits across all spanned columns plus separators.

Let me read the calculateColumnWidths function again and update it:Now I need to update `calculateColumnWidths` to also consider spanned cells. The approach is:
- For cells with colspan > 1, their content width should be distributed across the spanned columns
- Since we're measuring minimum content width, a spanning cell contributes to the minimum if its content is wider than the sum of the spanned columnsNow I need to add a second pass for spanning cells that need to expand columns when their content is wider than the combined spanned width. Let me add this after the min/max constraints are applied:Now I need to add spanning cell width distribution. This is done after the base widths are calculated but before padding is added:Now I need to update the render function to render spanned rows. First, let me find the render function and see how it loops through rows:I need to update the render function to include spanned rows. The rendering order should be: text rows, rich rows, then spanned rows - or we could interleave them. For simplicity, let's render spanned rows after the other row types:Now I need to add the `renderSpannedDataRow` function. Let me find where the other render functions are:Now let me see the getRowStyle function:Now I'll add the `renderSpannedDataRow` function and a helper for getting spanned row styles. Let me add this after `renderRichDataRow`:Now I need to add the `getSpannedRowStyle` function and the `renderSpannedCell` function. Let me find where getRowStyle ends:Let me add `getSpannedRowStyle` after `getRowStyle`:Now I need to add the `renderSpannedCell` function. Let me find where `renderRichCell` ends:Now I'll add the `renderSpannedCell` function after `renderRichCell`:Now let me run the tests to see if there are any compilation errors first:Tests pass. Now let me also run any table-specific tests to verify the basic functionality still works:All existing tests pass. Now let me add tests for the new spanning functionality and also handle horizontal borders with spans (for show_lines mode).

For row spanning, the implementation is more complex because it requires tracking state across multiple render calls. Let me first add the column spanning tests, then address row spanning.Row spanning is significantly more complex because:
1. It requires tracking which cells from previous rows still "occupy" cells in the current row
2. The grid layout needs to track "blocked" positions
3. Horizontal borders need to be aware of row spans to not draw lines through spanning cells

For a complete implementation, I'll add a row span tracking system. Let me implement this properly:For row spanning, I need to add a tracking structure during rendering. The approach is:
1. Create a `RowSpanTracker` that tracks which cells are "blocked" by row spans from previous rows
2. During rendering, check this tracker before rendering each cell position
3. Update the tracker after each row

Let me add a helper struct for row span tracking and update the render logic:Now I need to update the render function to use this tracker for spanned rows and to properly handle row spans during rendering. Let me find the render function and update it:I need to update the render function to use the RowSpanTracker for spanned rows. Let me update the rendering of spanned rows to use this tracker:Now I need to add the `renderSpannedDataRowWithTracker` and `renderHorizontalBorderWithSpans` functions, and update the existing `renderSpannedDataRow` to work with both cases (with and without tracker). Let me find the current `renderSpannedDataRow` function and update it:Let me find where the `renderSpannedDataRow` function ends and add the new tracker-aware version:Now I'll add the tracker-aware row rendering function and the horizontal border function with span awareness after the existing `renderSpannedDataRow`:Now let me run the tests to check for compilation errors:There's an unused variable. Let me fix it:Tests pass. Now let me update the todo list and add comprehensive tests for the spanning functionality:Now let me add comprehensive tests for the spanning functionality. Let me find the test section of the file:Let me find the end of the file to add tests:Now I'll add comprehensive tests for the Cell type and spanning functionality at the end of the file:Now let's run the tests to verify everything works:All tests pass. Let me also verify by running a quick visual test:Excellent! The demo runs correctly. Now let me update the version number in build.zig.zon since this is a new feature:The version is already 0.11.0 which is appropriate for this minor feature addition. Let me update the todo list and verify everything is complete:Let me also ensure the Cell type is exported in the module's public API:I need to add the `Cell` type to the public exports:Now let me run all tests one more time to ensure everything works:All tasks are complete. Now let me commit the changes:The implementation is complete. Here's a summary of what was implemented:

## Summary: Table Row/Column Spanning (Merged Cells)

### New Types

**`Cell`** - A cell struct that supports spanning:
- `content: CellContent` - The cell's content (text or segments)
- `colspan: u8` - Number of columns to span (default: 1)
- `rowspan: u8` - Number of rows to span (default: 1)
- `style: ?Style` - Optional cell-specific style override
- `justify: ?JustifyMethod` - Optional cell-specific justification override

**Builder methods:**
- `Cell.text("content")` - Create a text cell
- `Cell.segments(segs)` - Create a cell with styled segments
- `.withColspan(n)` - Set column span
- `.withRowspan(n)` - Set row span
- `.withStyle(style)` - Set cell style
- `.withJustify(justify)` - Set cell justification

### New Table Methods

- `addSpannedRow([]const Cell)` - Add a row with potentially spanning cells
- `addSpannedRowStyled([]const Cell, Style)` - Add a spanned row with row style

### Internal Implementation

- `RowSpanTracker` - Tracks which columns are blocked by row spans from previous rows
- Updated width calculation to handle colspan cells
- Horizontal borders respect row spans (show spaces instead of lines when a row span continues)

### Example Usage

```zig
var table = Table.init(allocator);
_ = table.addColumn("A").addColumn("B").addColumn("C");

// Cell spanning 2 columns
try table.addSpannedRow(&.{
    Cell.text("spans two").withColspan(2),
    Cell.text("single"),
});

// Cell spanning 2 rows
try table.addSpannedRow(&.{
    Cell.text("tall").withRowspan(2),
    Cell.text("row1"),
    Cell.text("row1"),
});
try table.addSpannedRow(&.{
    Cell.text("row2"),
    Cell.text("row2"),
});
```